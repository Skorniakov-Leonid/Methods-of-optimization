import random
from abc import ABC, abstractmethod
from dataclasses import dataclass
from inspect import signature
from typing import Callable

import numpy as np
import sympy


@dataclass
class Point:
    """Class for n-dimensional point"""
    coordinates: np.ndarray

    def distance(self, point: "Point") -> float:
        return np.linalg.norm(np.array(self.coordinates[:-1]) - np.array(point.coordinates[:-1]))


class Oracul(ABC):
    """Interface for oracul (anonymous value generator in point)"""

    @abstractmethod
    def evaluate(self, point: Point) -> float:
        """
        Get value in point
        :param point:       point for evaluating
        :return:            calculated value
        """
        pass

    @abstractmethod
    def get_dimension(self) -> int:
        """
        Get dimension of oracul
        :return:            dimension
        """
        pass


class GradientOracul(Oracul):
    """Interface for oracul that can calculate gradient in point multiple times"""

    @abstractmethod
    def evaluate_gradient(self, point: Point) -> np.ndarray:
        """
        Get gradient in point
        :param point:       point for calculating gradient
        :return:            calculated gradient
        """
        pass


class HessianOracul(GradientOracul):
    """Interface for oracul that can calculate gradient in point"""

    @abstractmethod
    def evaluate_hessian(self, point: Point) -> np.ndarray:
        """
        Get hessian in point
        :param point:       point for calculating gradient
        :return:            calculated hessian
        """
        pass


class SymbolOracul(HessianOracul):
    """Oracul that automatically calculates gradients and hessians through sympy"""

    def __init__(self, func, dimensions_order: list[str]):
        self.func = func
        self.dimensions_order = dimensions_order
        self.grad = np.array([])
        for i in self.dimensions_order:
            self.grad = np.append(self.grad, sympy.diff(self.func, i))
        self.hes = []
        for i in self.dimensions_order:
            row_res = []
            for j in self.dimensions_order:
                row_res.append(sympy.diff(sympy.diff(self.func, i), j))
            self.hes.append(np.array(row_res))
        self.hes = np.array(self.hes)

    def map_dim_to_point(self, point: Point) -> dict:
        return dict(zip(self.dimensions_order, point.coordinates))

    def evaluate(self, point: Point) -> float:
        return np.float64(self.func.subs(self.map_dim_to_point(point)))

    def get_dimension(self) -> int:
        return len(self.dimensions_order) + 1

    def evaluate_gradient(self, point: Point) -> np.ndarray:
        res = [np.float64(i.subs(self.map_dim_to_point(point))) for i in self.grad]
        return np.array(res, dtype=np.float64)

    def evaluate_hessian(self, point: Point) -> np.ndarray:
        res = []
        for i in self.hes:
            row_res = []
            for j in i:
                row_res.append(np.float64(j.subs(self.map_dim_to_point(point))))
            res.append(np.array(row_res))
        return np.array(res)


class LambdaOracul(Oracul):
    """Class for oracul from lambda"""

    def __init__(self, func: Callable[..., float]) -> None:
        """
        Constructor for lambda oracul
        :param func:        lambda that generate oracul
        """
        self.func = func
        self.dimension = len(signature(func).parameters) + 1

    def evaluate(self, point: Point) -> float:
        return self.func(*(point.coordinates[:self.dimension - 1]))

    def get_dimension(self) -> int:
        return self.dimension


class GradientLambdaOracul(LambdaOracul, GradientOracul):
    """Class for gradient oracul from lambda"""

    def __init__(self, func: Callable[..., float], gradient_func: Callable[..., np.ndarray]) -> None:
        """
        Constructor for gradient lambda oracul
        :param func:            lambda that generate oracul
        :param gradient_func:   function that generate gradient for that lambda
        """
        super().__init__(func)
        self.gradient_func = gradient_func

    def evaluate_gradient(self, point: Point) -> np.ndarray:
        return self.gradient_func(*(point.coordinates[:self.dimension - 1]))


class PoweredSumOracul(GradientOracul):
    """Class for oracul generated by coefficients"""

    def __init__(self, coefficients: list[tuple[float, float]]) -> None:
        """
        Constructor for powered sum oracul
        :param coefficients:    coefficients in style [(coefficient of x, power of x), (coefficient of y, power of y)...]
        """
        self.coefficients = coefficients

    def evaluate(self, point: Point) -> float:
        res = np.float64(0)
        for coordinate, coefficient, power in zip(point.coordinates, self.coefficients):
            res += coefficient * (np.float64(coordinate) ** power)
        for i in range(len(self.coefficients)):
            res += self.coefficients[i][0] * (np.float64(point.coordinates[i]) ** self.coefficients[i][1])
        return res

    def evaluate_gradient(self, point: Point) -> np.ndarray:
        res = np.zeros(len(self.coefficients), dtype=np.float64)
        for i in range(len(self.coefficients)):
            res[i] = (np.float64(point.coordinates[i]) ** np.float64(self.coefficients[i][1] - 1)) * \
                     self.coefficients[i][0] * \
                     self.coefficients[i][1]
        return res

    def get_dimension(self) -> int:
        return len(self.coefficients) + 1


class NoiseOracul(Oracul):
    """Class for oracul with noised evaluate"""

    def __init__(self, oracul: Oracul, start_noise: float, end_noise: float) -> None:
        """
        Constructor for noise oracul
        :param oracul:      oracul that noised
        :param start_noise: minimal noise
        :param end_noise:   maximal noise
        """
        self.oracul = oracul
        self.start_noise = start_noise
        self.end_noise = end_noise

    def evaluate(self, point: Point) -> float:
        return self.oracul.evaluate(point) + random.uniform(self.start_noise, self.end_noise)

    def get_dimension(self) -> int:
        return self.oracul.get_dimension()

    def evaluate_gradient(self, point: Point) -> np.ndarray:
        return self.oracul.evaluate_gradient(point)


class MultiLambdaOracul(Oracul):
    """Class for oracul by composite function"""

    def __init__(self, func: Callable[[np.ndarray, int], float], n: int, start_sum: int = 0):
        self.func = func
        self.n = n
        self.dimension = len(signature(func).parameters) + 1
        self.start_sum = start_sum

    def evaluate(self, point: Point) -> float:
        res = 0
        for i in range(self.start_sum, self.n):
            res += self.func(point.coordinates, i)
        return res

    def get_dimension(self) -> int:
        return self.dimension


class MultiGradientLambdaOracul(MultiLambdaOracul, GradientOracul):
    """Class for gradient oracul by composite function"""

    def __init__(self, func: Callable[[np.ndarray, int], float], grad: Callable[[np.ndarray], np.ndarray], n: int,
                 start_sum: int = 0):
        super().__init__(func, n, start_sum)
        self.grad = grad

    def evaluate_gradient(self, point: Point) -> np.ndarray:
        return self.grad(point.coordinates)
